[TOC]

# [study note]C++核心

## 内存分区模型

> C++程序在运行的时候内存划分为**==四个区域==**

- 代码区:存放二进制代码,由操作系统进行管理
- 全局区:存放*全局变量*和*静态变量*以及*常量*
- 栈区:*编译器*自动分配释放,存放函数的参数值,局部变量等
- 堆区:*程序员*分配释放,程序结束由操作系统回收

### 运行前

> 程序编译后,生成了`.exe`可执行程序,为*执行程序前*分为两个区域

**代码区**:

- **共享**:对于频繁被执行的 程序只需要一份代码即可
- **只读**:防止程序被意外修改

**全局区**:

> ==在程序结束后释放==

- 全局区
  - 全局变量
  - 静态变量(`static`修饰的变量)
  - 字符串常量
  - `const`修饰的全局变量(全局常量)

- 不在全局区
  - 局部变量
  - `const`修饰的局部变量

> 局部变量:在函数中定义的变量(包括在`main`函数中的变量)
>
> 全局变量:不在函数中的变量
>
> 静态变量:在局部变量前加`static`
>
> 常量: 
>
> - 字符串常量 `“helloworld”`
> - 全局常量(在全局变量前加`const`)
> - 局部常量(在局部变量前面加`const`)
>   - 与局部变量放在一起

### 程序运行后

#### 栈区

- *编译器*自动分配释放,存放函数的参数值,局部变量等
- 注意:不要返回 局部变量的地址(函数执行完后内存被释放了)

#### 堆区

- *程序员*分配释放,程序结束由操作系统回收
- C++中利用[`new`](####new操作符)在堆区开辟内存

在堆区开辟数据

```c++
#include<iostream>
using namespace std;
int* function1()
{
    //在堆中开辟出空间存放数据
    //new返回一个地址
    int *p = new int(20);//p指针本质上也是局部变量,放在栈上.指针保存的数据放在堆区
    return p;
}
int main()
{
    //在堆区存放的数据
    int *p = function1();
    cout << *p << endl;
}
```

#### new操作符

> C++中利用`new`操作符在**堆区开辟内存空间**
>
> 堆区开辟的数据手动释放使用操作符`delete`

语法:`new数据类型(数值)`

利用`new`开辟的数据会*返回该数据的指针*

在堆区开辟完**返回指针地址**

```c++
int *p=new int(10);
```

释放堆区内存

```c++
delect p;
```

Eg 

```c++
#include<iostream>
using namespace std;
int* func()
{
    //在堆区创建整型数据类型,返回指针地址
    int *p = new int(10);
    return p;
}
int main()
{
    //读取堆区数据
    int *p = func();
    cout << *p << endl;
    //释放堆区数据
    delete p;
}
```

在堆区创建一个数组空间

Eg 

```c++
int* func()
{
    //在堆区中创建一个数组
    int *arr=new int[10];
    //给数组赋值
    for (int i = 0; i < 10;i++)
    {
        arr[i] = i;
    }
    return arr;
}
int main()
{
    int *arr = func();
    //打印堆区数组
    for (int i = 0; i < 10; i++)
    {
        cout << arr[i] << endl;
    }
    //释放数组时候要使用[]
     delete[] arr;
}
```

## 引用

> 指针的本质是C++内部实现了一个指针常量

### 引用基本

> 引用:给变量起别名

**语法**:数据类型 &别名=原名

```c++
int main()
{
    int a = 10;
    //给a起别名b
    //创建引用
    int &b = a;
    b = 20;
    cout << a << endl;
}
```

**注意**:

- 引用必须初始化(`int &b`错误的)
- 引用在初始化后不可以改变

### 引用做函数参数

> **作用**:函数传递参数的时候,可以使用引用传递实参
>
> ·相当于传递指针·

Eg :

```c++
void exchange(int &a,int &b)//引用传递,变量本身被传递过去
{
    int temp = a;
    a = b;
    b = temp;
}
int main()
{
    int a = 10;
    int b = 20;
    exchange(a, b);
    cout << "a=" << a << endl;
    cout << "b=" << b << endl;
}
```

### 引用做函数返回值

1. 不能返回局部变量的引用

   以下函数返回引用方式**有误**

   ```c++
   int& func()
   {
       int a = 10;//变量放在堆区,在函数运行完毕后被释放
       return a;
   }
   int main()
   {
       int res = func;
       cout << "res=" << res << endl;
   }
   ```

   **正确**返回引用方式:

   ```c++
   int& func()
   {
       static int a = 10;//全局变量,在程序结束后才释放
       return a;
   }
   int main()
   {
       int &res = func();
       cout << "res=" << res << endl;
   }
   ```

2. 函数返回的是引用,函数的调用可以==作为左值==,可以直接操作函数中返回的变量.

```c++
#include<iostream>
using namespace std;
int& func()
{
    static int a = 10;//全局变量,在程序结束后才释放
    return a;
}
int main()
{
    int &res = func();
    cout << "res=" << res << endl;
    func() = 2000;//如果函数返回引用,函数调用可以作为左值,可以直接操作返回的变量值
    cout << "res=" << res << endl;
}
```

3. 常量引用

> 用`const`修饰形参,防止修改形参误操作实参

- `const int &a=10`常量引用,加入`const`不能修改变量

- 在形参中加入`const`使实参不发生改变,防止误操作(只读不写)

```c++
void print(const int &a)
{
    //形参被const修饰,函数中不能修改a,防止误操作
    cout << a << endl;
}
int main()
{
    int a = 20;
    print(a);
}
```

- 可以使用`const int &a=10`进行赋值

## 函数plus

### 函数默认参数

> 语法:`返回值类型 函数名 (参数=默认值){}`

注意:

- 函数形参从某个位置开始有了默认参数,则之后的形参都必须有默认值`int func(int a,int b=10,int c=20)`
- 当实参传入值,函数**使用实参传入的值**,不使用默认值
- 函数声明和函数实现只能有一个有默认参数

函数默认参数

```c++
int pl (int a,int b=10,int c=100)
{
    return (a + b + c);
}
int main()
{
    int a = 20;
    int b = 2;
    cout << pl(a) << endl;//结果130
    cout << pl(a, b) << endl;//结果122,函数使用了传入的形参,而非形参默认值
}
```

### 函数占位参数

> 形参列表可以有占位参数,用作占位,调用时必须填补该位置

语法:`返回值类型 函数名(数据类型){}`

```c++
#include<iostream>
using namespace std;
void func(int a,int)//函数占位参数
{
    cout << "a=" << a << endl;
}
int main()
{
    //占位符要传入数据
    func(20, 100);
}
```

- 在主函数调用函数时需要传入占位参数的实参

```c++
 void func(int a,int);
func(30);//不传入占位参数语法错误
func(20, 100);//正确的方式
```

- 占位参数也能有默认值

```c++
void func(int a,int=10);
func(20);//函数调用
```

### 函数重载

> 函数名相同,提高复用性

满足条件:

- 同一个作用域
- 函数名称相同
- 函数**参数**不同,或者**个数**不同,**顺序**不同,*返回类型不能区分*相同函数名的函数

> ~~人话:**参数**不同就可以区分相同名字的函数~~  

注意:当函数重载**存在默认值时会出现二义性**,尽量避免.

## 类和对象

> C++面向对象特征:封装,继承,多态
>
> 对象上有其对应的==**属性**==和==**行为**==
>
> 具有*相同性质的对象*可以抽象的称之为**类**

### 封装

> 三大特性之一

封装的意义:

- 将属性和行为作为一个整体
- 将属性和行为加以权限控制

语法:`class 类名{访问权限:属性/行为};`

类中的属性和成员称为**成员**

属性也称为成员属性;成员变量. 

行为也称为成员函数;成员方法

```c++
#include<iostream>
using namespace std;
#define PI 3.14
// 创建一个类,圆类
class circle
{
    //权限
    //公共权限
    public:
    //属性
        int r;
        //行为
        double calulate()
        {
            return 2 * PI * r;
        }
};
int main()
{
    //通过圆类,创建一个圆
    circle c1;
    c1.r = 10;
    cout << "圆的半径为:" << c1.r << endl;
    cout << "周长为: " << c1.calulate() << endl;
}
```

在类设计时候,可以把属性放在不同的权限下加以控制.访问权限有以下三种:

1. `public` 公共权限    
   - 成员在类内可以访问,类外可以访问
2. `protected`保护权限  
   - 类内可以访问,类外不可以访问
3. `private`私有权限
   - 类内可以访问,类外不可以访问

`struct`和`class`的区别在C++中是**默认的访问权限不同**

- `struct`默认权限是**公共**
- `class`默认权限是**私有**

### 构造函数和析构函数

> 对象的**初始化**和**清理**也是非常重要的事情,一个对象或者变量没有进行初始化,对其使用后果是未知的,同样变量没有及时清理会造成安全问题

C++中利用了**构造函数**和**析构函数**解决上述问题,两个函数被编译器*自动调用*,如果**程序员不提供构造和析构函数,编译器提供的构造和析构函数是空实现**

- 构造函数:作用在创建对象时为对象成员属性赋值
- 析构函数:作用在于对象**销毁前**系统自动调用,执行清理作用

#### 构造函数

> 对象初始化

语法:`类名(){}`

- 没有返回值也不写`void`
- 函数名与类名相同
- 构造函数可以有参数,可以发生重载
- 程序在调用对象的时候会自动调用构造,而且只会调用一次

构造函数分类:

- 按参数分为:有参构造和无参构造
- 按类型分为:普通构造和拷贝构造

有参构造函数:

```c++
person(int a)
{
  age=a;
}
```

拷贝构造函数:把传入的对象属性拷贝到自身上

```c++
//拷贝构造函数
    person(const person &p)
    {
        //将传入对象的属性拷贝过来
        age = p.age;
    }
```

##### 调用方式:

- 括号法

  调用默认构造函数时,不要加`()`,`person p1()`编译器会认为是一个函数声明

  ```c++
  person p1;//默认构造函数调用
  person p2(10);//有参构造函数调用
  person p3(p2);//拷贝构造函数调用 
  ```

- 显示法

  ```c++
  person p1;
  person p2=person(10);//有参构造
  person p3=person(p2);//拷贝构造
  ```

  - `person(10)`是匿名对象,当前执行结束后,系统会立刻回收匿名对象
  -  不要用拷贝构造函数初始化匿名对象,编译器会认为`person (p3)===person p3;`

- 隐式转换法

  ```c++
  person p4=10;//相当于person p4=person(10);
  ```

 拷贝构造函数调用的时机:

1. 使用一个已经创建完毕的对象来初始化一个新对象

   ```c++
   person p1(20);
   person p2(p1);
   ```

2. 值传递的方式给函数参数传值

   ```c++
   void dowork(person p)
   {
    
   }
   void tect()
   {
     person p1;
     dowork(p1);//在值传递的过程中使用了拷贝构造函数
   }
   ```

3. 值方式返回局部对象

   ```c++
   void dowork()
   {
     person p1;//栈上变量,函数结束时会被释放
     return p1;//在释放前拷贝一份数据,使用拷贝构造函数,进行值返回
   }
   void tect()
   {
     person p=dowork();//使用返回值进行初始化
   }
   ```


##### 构造函数调用规则

默认情况下,编译器在编写类会添加3个函数

> 至少会提供一个函数

- 默认构造函数(无参,函数体为空)
- 默认析构函数(无参,函数体为空)
- 默认拷贝构造函数,对属性进行值拷贝

构造函数调用规则如下:

- 如果用户定义有参构造函数,c++不会提供无参构造,但是会提供默认拷贝构造
- 如果用户定义拷贝构造函数,,*c++不会再提供其他构造函数*(包括有参构造和无参构造函数)

#### 析构函数

语法:`~类名(){}`

- 没有返回值也不写`void`
- 函数名与类名相同,在名称前加`~`
- 析构函数**不能**有参数,因此不能发生重载
- 程序在**对象销毁前**的时候会自动调用构造,而且只会调用一次

#### 深拷贝和浅拷贝

> 浅拷贝:简单的赋值拷贝操作
>
> 深拷贝:在堆区重新申请空间,进行拷贝操作

浅拷贝存在问题:当使用析构函数的时候容易**对同一块堆区内存重复释放**,造成违法操作.

编译器提供的构造函数是浅拷贝,在赋值指针类型时容易出现上述浅拷贝的问题

为解决上述浅拷贝,使用深拷贝方法,**重新申请堆区空间进行拷贝操作(深拷贝)**

> 堆区开辟内存关键字`new 数据类型()`
>
> 清空堆区数据使用`deleter`

以下是使用深拷贝的拷贝构造函数

```c++
//拷贝构造函数
    person(const person &p1)
    {
        age = p1.age;
        heighet = new int(*p1.heighet);//深拷贝,重新在堆区开辟一片内存存放拷贝的数据
    }
```

如果不写拷贝构造函数,编译器会自动生成浅拷贝构造函数,直接赋值拷贝操作

```c++
//编译器生成的浅拷贝函数
person(const person &p1)
{
  height=p1.heighet;//直接赋值拷贝
}
```

