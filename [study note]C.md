[TOC]



# :book::book:[Study Note]C

## 类型系统

> 常量其值不会发生改变
>
> > 获取变量长度：
> >
> > `sizeof`关键字可以返回传入变量的长度
> >
> > 格式：`sizeof(变量名)`

### 整数

类型：

- `short`
  - 占用字节数：2

- `int`
  - 占用字节数：4

- `long` 
  - 声明:`long c=100000L;`
  - 输出:`printf("%LLd\n",c);`
  - 占用字节数：4

- `longlong`
  - 声明:`longlong d=1000000LL;`
  - 输出;`printf("%LLd\n",c);`
  - 占用字节数：8

- `signed int`
  - 有符号整数（正数，负数，0）
  - 占用字节数：4

- `unsigned int`
  - 无符号整数
  - 仅表示（正数，0）
  - 输出:`printtf("%u",c);`
  - 占用字节数：4

---



### 小数



类型:

- `float`
  - 精准到小数点后6位
  - 声明:`float a=3.14F;`
  - 占用字节数：4
- `double`
  - 精准到小数点后15位
  - 声明:`double a=3,14;`
  - 输出:`printf("%Lf",a);`
  - 占用字节数：8
- `long double`
  - 声明`long double a=1.373837L; `
  - 占用字节数：8

---



### 字符

> 包括字母，数字，英文字符，但不***包括中文***

类型：

- `char`

  - 声明:`char a[内存占用]；`

  - 占用字节数：1

  - 内存占用计算

    1. 英文：一个字母，符号，数字占用一个字节

    2. 中文:占用两个字节
  
    3. **结束标记占用一个字节**

summary:

取值范围：`double>float>longlong>long>int>short`

后缀：`float(F),long(L),longlong(LL)`

变量名字尽量用英文单词，开头不能是数字，而且不能是关键符，区分大小写。

---

符号变量： `#define PI 3.1415926`对PI进行预处理，后续可以直接使用这个变量，并且能“一改全改”（没有内存单元分配）

常变量：`const float pi=3.1415926`数值不发生改变的变量（分配了内存单元）

### 常用的转义字符

- `\'`单撇号字符 	`\''`双撇号字符	`\?`问号字符	`\\`反斜线字符
  - `\b`退格	`\n`换行	`\r`回车	`\t`水平制表符（TAB)
    - `\o`八进制对应的字符	`\xh`十六进制对应的字符

## 键盘录入

> scanf(”%d\n”,&变量名）
>
> 记得加#define  
>

e.g.

```c
int a;
int b;
scanf("%d %d",&a,&b);
printf("%d\n",a);
printf("%d\n",b);
```

`scanf`函数返回一个整数值，表示成功读取并赋值的输入项的数量，**用于判断输入是否成功**

eg.

```c
status = scanf("%f", &x);//用于判断是否被赋值成功，成功返回1，失败则返回0
```



## 运算符

> 通用细节：
>
> 1.整数计算结果是整数，==**小数计算结果是小数。整数与小数计算结果也是小数**==
>
> 2.只要有小数参与计算，结果就可能不精确
>
> > 隐式转换
> >
> > 1. 把取值范围小的换成大的   取值范围：`double>float>longlong>long>int>short`
> > 2. `short`，`char`在运算时会提升为`int`。

### 自增自减

- `++`自增加1
- `--`自减减1

​    Ps:`i++`表示**先用后加**（表达式用完了再自增），`++i`表示**先加后用** 

### 逻辑运算符

>用数字`1`表示真，`0`表示假。（同时**非零的数值也代表真**）

类型:

- `&&`
  - 表示：和（**同时满足**）

- `||`
  - 表示：或者(**两者满足其中一个**)
  - 注意:如果`||`左边运行成功，右边就不会运行。

### 三元运算符

类型：

- `a>b?a:b`

  - > a和b进行判断，若成立运行a，反之运行b。

### 优先级

1. （）优先于所有
2. 一元>二元>三元
3. &&>||>赋值

## 循环语法

> 1. `break`：（只写在switch或者循环语句中）跳出本层循环体，从而提前**结束本层循环**
>
> 2. `continue`（只写在循环中）结束单次循环，`continue`语句的作用是**结束本次循环**，即跳过本次循环体中余下尚未执行的语句，然后直接进行下一次循环条件的判断，而不是使整个循环终止。
>
> 3. go to 跳出多层循环  (直接跳转到a处)
>
>    e.g.
>
>    ```
>    go to a
>    ......
>    a:
>    ```
>

### if表达式

表达:

```c
if（表达式）
{
语句体
}
else if（表达式）
{
语句体
}
else
{
语句体
}
```

### switch

作用：用来匹配相应的值

e.g.

```c
seitch(表达式)
{
case 值1;
语句体1;
break;
case 值2;
语句体2;
break;
.....
default:
语句体n;//当数值都不符合就运行此处代码
}
```

ps:

1. `break`中断结束`switch`
2. `defaul`t：所有情况不匹配执行此处代码 

### for循环

e.g.
```
for(初始语句;条件判断语句;条件控制语句)
{
循环体语句;
}
```

application:

- 统计:定义一个变量在符合条件时候自增`int count=0;`

### while循环

> `for`和`while`的区别：`for`用于**确定的范围**，`while`用于**不确定范围**

e.g.

```c
while(1)
{
循环体语句;
}
```

### 注意事项

- 循环嵌套逻辑：先确定内循环，外循环就是重复执行内循环

## 函数

> 定义函数格式：
>
> ```c
> 返回值类型 函数名 (形参1,形参2......)
> {
> 函数体;
> return 返回值;
> }
> ```
>



---



### 随机数

e.g.

```c
#include<stdio.h>
include<time.h>
srand(time(NULL));//设置种子
int num=rand()%a+b//获取范围，设置范围（1-100）a=(100+1)-1,b=1(范围开头）

```



## 数组

> - 定义格式: `数据类型` `数组名`[长度]={a,b,c.......}
>
> - 个数：`int len=sizeof(arr)/sizeof(数据类型);`

### 获取数组的值

`int 变量=arr[索引];`//索引从0开始，小于`len`。

### 遍历数组

e.g.

```
for(int i=0;i<len;i++)
{
printf("%d\n",arr[i]);
}
```

## 数组查找

1. 顺序查找

> 按顺序一次查找（~~效率不高~~)

```c
int sequential(int arr[], int len, int num)
{
	for (int i = 0; i < len; i++)
	{
		if (arr[i] == num)
		{
			return i;
		}
	}
	return -1;
}
```

2. 二分查找

> 有序,且分布均匀

```c
int search(int arr[], int len, int num)
{
	//先定义max和min作为范围
	int min = 0;
	int max = len - 1;
	while (min <= max)
	{
		int mid = (max + min) / 2;
		if (arr[mid] == num)
		{
			return mid;
		}
		else if (arr[mid] > num)//数字在mid的左边，范围缩小
		{
			max = mid - 1;
		}
		else if (arr[mid] < num)//数字在mid的右边，范围缩小
		{
			min = mid + 1;
		}
		
		
			return -1;
		
	}
}
```

3.分块查找

![image-20241015190148971](D:\Jason\image-20241015190148971.png)

- 分块原则1：前一块最大的数字小于后一块的所有数据

- 分块原则2：块数一般等于数字个数开根号（16个数字分4块）

- 思路：**先确定在哪一块，然后再块里找**

无规律的数据

将其分成互相==**没有交集**==的几块

4. 冒泡查找

- 相邻的元素两两比较，大的放右边，小的放左边。
- 第一轮比较完毕后，==最大值已经确定(在最右边)== ，第二轮可以少循环一次，后面以此类推。
- 如果数组中有n个数据，总共需要执行n-1轮的代码就可以。

e.g.

```c
int main()
{
	int arr[] = { 3,5,2,1,4 };
	int len = sizeof(arr) / sizeof(int);
	//冒泡查找，就是两个数组进行比较，大的向右移动
	for (int j = 0; j < len - 1; j++)//总共要进行len-1次循环
	{
		for (int i = 0; i < len - 1-j; i++)//-j目的是每次少处理一次
		{
			if (arr[i] > arr[i + 1])//向右交换
			{
				int a = arr[i];
				arr[i] = arr[i + 1];
				arr[i + 1] = a;
			}
		}
	}
	for (int i = 0; i < len; i++)
	{
		printf("%d ", arr[i]);
	}
	return 0;
}
```

5. 选择排序

![image-20241015190906830](C:\Users\Jason\AppData\Roaming\Typora\typora-user-images\image-20241015190906830.png)

选择排序的基本步骤：

- 从0索引开始，眼后面的元素一一比较。

- 小的放前面，大的放后面。

- 第一轮循环结束后，**最小的数据已经确定在最左边**。

- 第二轮循环从1索引开始以此类推。

- 第三轮循环从2索引开始以此类推。

- 第四轮循环从3索引开始以此类推。

e.g.

```
int main()
{
	int arr[] = { 3,5,2,1,4 };
	int len = sizeof(arr) / sizeof(int);
	//选择排序：从0索引开始，一次和后面每一个索引进行比较
	//小的放左边，大的放右边
	for (int j = 0; j < len - 1; j++)
	{
		for (int i = j+1; i < len ; i++)//内循环
		{
			//i依次表示j后面的索引
			if (arr[j] > arr[i])//大的放右边
			{
				int a = arr[j];
				arr[j] = arr[i];
				arr[i] = a;
			}
		}
	}
	for (int i = 0; i < len; i++)
	{
		printf("%d", arr[i]);
	}
	return o;
}

```

```c
//选择法：在数组中找出最小值，并把他放在开头（与开头的数字对调）
void selectSort(int num[],int n);//n表示数组长度
{ 
  for(int a=0;a<n;a++)
  {
    int minindex=a;
    for(int i=0;i<n;i++)
    {
        if(num[minindex]>num[i])
        {
            minindex=i;
        }
    }
    if(minindex!=a)
    {
        int temp=num[minindex];
        num[minindex]=num[a];
        num[a]=temp;
    }
  }
}
```



## 指针

> - 指针本质是内存地址,指针变量是存放地址的变量
>
> - 定义格式： 数据类型*变量名    ``e.g. int a=10;   ``
>
>   ``int *p1=&a;`

x86-32位环境,指针大小占`4`个字节(byte)

### 指针作用

#### 查询数据

*p(`*`作用为解引用运算符,**与定义上的不同 **)

- 输出：`printf("%d",*p);`

获取变量地址:

`printf("%p\n",p1);`

#### 存储数据

> `*p=200`;   此时变量`a`的值为`200`； 

#### 使用函数对调两个数，可以使用指针的方式 

```c
void swap(int *p1,int *p2)
{
int temp=*p1;
*p1=*p2;
*p2=temp;
}
```

> 要使函数中的变量能都一直存在，可以在变量前面加`static`关键字
>
> ```c
> int methed()
> {
> static int a=10;
> return &a
> }
> ```

#### 函数返回多个值

e.g. 定义一个函数，求数组的最大值和最小值，并进行返回

```
#include<stdio.h>
//定义一个函数
void getmaxandmin(int arr[], int len, int* max, int* min)
{
	*max = arr[0];
	*min = arr[0];
	//找出最大值
	for (int i = 1; i < len; i++)
	{
		if (arr[i] > *max)
		{
			*max = arr[i];
		}
	}
	//找出最小值
	for (int i = 1; i < len; i++)
	{
		if (arr[i] < *min)
		{
			*min = arr[i];
		}
	}

}
int main()
{
	//定义一个函数，求数组的最大值和最小值，并进行返回
	int arr[] = { 1,2,3,4,5,6,7,8,9};
	int len = sizeof(arr) / sizeof(int);
	int min=arr[0];
	int max=arr[0];
	getmaxandmin(arr, len, &min, &max);
	printf("最大值为%d", max);
	printf("最小值为%d", min);
}

```

#### 函数的结果和计算状态分开

> 函数可以单独返回状态（e.g. 1代表运行失败，0代表运行成果)

e.g.

定义一个函数，将两数相除获取他们的余数

```c
#include<stdio.h>
//定义一个函数，将两数相除获取他们的余数
 int getremainer(int num1,int num2,int *res)
{
//判断是否等于0
	if(num2==0)
	{
	//等于0时结束函数，返回1表示当前状态
		return 1;
	}
	*res = num1 % num2;//用指针接收结果
	return 0;//返回结果0表示运行成果
}
int main()
{
	int a = 10;
	int b = 3;
	int res = 0;
	int flag = getremainer(a, b, &res);
	if (flag == 0)
	{
		printf("%d", res);
	}
	else if(flag==1)
	{
		printf("数值无效。");
	}
	return 0;
}
```



### 指针高级

> 指针中数据类型的作用：获取字节数据的个数

#### 指针运算

> 步长=**数据类型**占用的字节长度：指针移动一次走了多少字节
>
> 具体长度参考：[类型系统](#类型系统)

- 加法：指针记录的内存地址往后移动n步`p+n`
  - 输出：`printf("%d\n",*(p+1));`

- 减法：指针记录的内存地址往后移动n步`p-n`
  - 输出：`printf("%d\n",*(p-1));`
- 指针之间相**减**可以得到间隔步长  ~~ps:指针之间相加乘除不成立，整数与指针乘除也没有意义~~
  - 输出：`printf("%p\n",p1-p2);`

> ~~野指针~~：指针指向的空间未分配
>
> ~~悬空指针~~：指针空间已分配，但被释放



- 特殊类型`void *p`不表示任何类型
  - 特点：**无法获得数据**，**无法计算**，但是可以接收任意地址
  - 不同类型的指针之间不能交换数据，`void`可以接收任何类型指针记录的内存地址

e.g.

> 交换两个数据的函数

```
void exchange(void *p1, void *p2, int len)//定义两个没有定义的指针接收两个数据
{
	//把void类型的指针转成char类型的指针。char占用一个字节
	char *pc1 = p1;
	char *pc2 = p2;
	int temp = 0;
	//以字节为单位，一个一个字节的进行交换（类型占用多长字节就循环几次）
	for (int i = 0; i < len; i++)
	{
		temp = *pc1;
		*pc1 = *pc2;
		*pc2 = temp;
		pc1++;
		pc2++;
	}
```

---

#### 二级指针

> 储存指针的内存地址
>
> - 定义：`int** 指针名字`
>
> - 作用1：二级指针可以操作一级指针记录的地址
>
>   e.g.
>
>   修改指针记录的地址`*pp=&b`,此时指针p记录的是变量b的地址
>
>   作用2：获取变量中记录的数据`printf("%d",**pp);`

#### 指针数组

> 利用指针去遍历数组

e.g.

```c
int arr[]={10,20,30,40};
int len=sizeof(arr)/sizeof(int);
int *p=arr;//获取了数组的首地址，指针退化
for(int i=o;i<len;i++)
{
 printf("%d\n",*p);
 p++;//地址向后移动
}
return 0;
```

细节：

- `sizeof`运算的时候不会退化
- `arr`参与计算时，会退化成第一个元素的指针
  - `*p=arr;`数组会退化成元素的指针，此时记录的是数组的首地址，**步长为：数据类型的长度**(int 4)
  - `*p=&arr`数组不会退化，此时记录的是数组的首地址，**步长为：数据类型的长度*数组长度**

#### 二维数组

- 定义1：

```c
int arr[3][4] =//3表示二维数组长度，4表示一维数组的长度
{
	{1,2,3,4},
	{5,6,7,8},
	{9,10,11,12}
};
```

- 索引遍历（**循环**）：

```c
for (int a = 0; a < 3; a++)//循环次数=二维数组长度
{
	for (int b = 0; b < 4; b++)//循环次数=一维数组长度
	{
		printf("%d\t", arr[a][b]);
	}
	printf("\n");//内循环遍历一维数组
}
```

- 索引遍历（**指针**）：

  > 定义数组指针`int (*p)[len]=&arr;`
  >
  > 操作数组数组中的数据

```c
int main()
{
	//定义一个二维数组的指针
	//格式：数据类型+数据名称
	int arr[3][4]=
	{
		{1,2,3,4},
		{11,22,33,44},
		{111,222,333,444}
	};
	int (*p)[4] = arr;
	//遍历数组
	for (int i = 0; i < 3; i++)
	{
		for (int j = 0; j < 4; j++)
		{
			printf("%d ", *(*p + j));//遍历一维数组的数据
		}//指针解两次，还要向后移动遍历下一个数据
		printf("\n");
		p++;//遍历下一个一维数组
	}
}
```

注意指针步长，`*p`为一个数组的步长，**p是一个一维数组数据类型（`len`）的步长

---



定义2：一个二维数组且包含的*一维数组的长度不相同*

- 先定义包含的一维数组,再存入二维数组里面`int*arr[]={arr1,arr2};指针数组`(此时arr1等**退化**)
- 遍历：在一维数组退化前先算出各自的长度并用数组记录下来`int lenarr[]={len1,len2};`在内循环即可使用`len`作为结束条件

e.g.

```
int main()
{
	//定义一个二维数组且包含的一维数组的长度不相同
	//先定义包含的一维数组,再存入二维数组里面
	int arr1[3] = { 1,2,3 };
	int arr2[4] = { 4,5,6,7};
	int arr3[2] = { 1,2 };
	int len1 = sizeof(arr1) / sizeof(int);//分别存下每个数组的长度
	int len2 = sizeof(arr2) / sizeof(int);
	int len3 = sizeof(arr3) / sizeof(int);
	int lenarr[3] = { len1,len2,len3 };//用数组储存
	int* arr[3] = {arr1,arr2,arr3};//数据类型与数据类型相同，此时记录的是地址，所以是int*
	//此时arr退化
	for (int i = 0; i < 3; i++)
	{
		for (int j = 0; j < lenarr[i]; j++)
		{
			printf("%d", arr[i][j]);
		}
		printf("\n");
	}
}
```

- 用指针遍历数组

```
//定义三个一维数组
int arr1[] = {1,2,3,4};
int arr2 [] = {11,22,33,44};
int arr3[] = { 111,222,333,444 };
//把三个一维数组的内存地址存进二维数组
int *arr[] = { arr1,arr2,arr3 };
//定义二维数组的指针
int** p = arr;
//遍历数组
for (int i = 0; i < 3; i++)
{
	for (int j = 0; j < 4; j++)
	{
		printf("%d ", *(*p + j));
	}
	printf("\n");
	p++;
}
```

#### 函数指针

## 字符串

> 定义:
>
> - 利用字符数组+双引号的方式定义：`char str[4]="abc";`
>   - 注意：
>     - 在底层，数据储存时，数组的*最后会有`\0`表示结束*，所以数组长度要加上`\0`的长度(`{'a','b','c','\0'}`)
>     - 内容可修改字符串内容`str[0]='Q';`
>   
>   ---
>   
>   - 字符串**不能使用`=`进行整体赋值**，需要通过`strcpy` 赋值
>   
> - 利用指针+双引号定义：`char* str="abc";`
>   
>   - 注意:
>     - 在底层，数据储存时，数组的最后会有`\0`表示结束，所以数组长度要加上`\0`的长度(`{'a','b','c','\0'}`)
>     - 这种方式定义字符串，字符数组放在**只读常量区**[内容不可修改，内容可以复用(`内存地址相同`)]

1. 利用二维数组存放”字符串数组“：

```
char string[3][100]=
{
"abcd",
"dcba",
"aabb",
"a"
};
//遍历
for(int i=0;i<3;i++)
{
char *p=srting[i];
printf("%s",p);
}

```

2. 利用指针数组存放：

```
char *string[3]=
{
 "abcd",
 "dcba",
 "aabb",
 "a"
};
```

### 字符串函数

> 头文件引入`#include<string.h>`

- `strlen`获取字**符串的长度**
  - 不计算结束标记
  - 一个中文占用两个字节 
- `strcat`**拼接**两个字符串
  - `strcat(str1,str2)`把第二个字符串的内容拷贝到一个字符串的**末尾**
  -  前提：
    - 第一个字符串是可以修改的（`char *str`是不可修改的）
    - 第一个字符串剩余空间可以容纳拼接的字符串
- `strcpy`复制字符串
  - `strcpy(str1,str2)`把第二个字符串的内容，拷贝到第一个字符串中然后覆盖原本的内容
  - 前提：
    - 第一个字符串是可以修改的（`char *str`是不可修改的）
    - 第一个字符串剩余空间可以容纳拼接的字符串
- `strcmp`比较两个字符串
  - `strcmp(str1,str2)`
  - 返回值 ：0(完全一样)  非0(不相同)
  - 细节：
    - ***顺序和内容***完全一样才认为是完全一样
    - 返回值：当字符为英文，字典位置在**后面**的为**大**，`str1`  在词典顺序大于`str2`,返回一个正数，小于或等于返回`0`/`负数`.
- `_strlwr`将字符串变成小写
  - 只能转换英文的大小写
- `_strupr`将字符串变成大写
  - 只能转换英文的大小写

## 结构体

> - 自定义的数据类型，由多个数据组合成的一个整体，每个数据都是这个结构体
> - 书写位置：
>   - 函数里面：局部位置，只能在本函数使用
>   - 函数外面：全局位置，在所有函数中都可以使用

e.g.

设置一个结构体然后赋值

```c++
struct boyfriend
{
char name[100];
int age;
double height;
};
int main()
{
struct boyfriend bf1;//定义一个结果体
//分别里面的参数赋值
//对字符串的赋值如下
strcpy(bf1.name,"jason");
bf.age=18;
bf.height=1.80;
}
```

同时可以如下赋值

```c++
struct boyfriend bf1={"jason",18,1.80};
```

遍历多个相同的数据组的时候，可以把它们放进一个数组里，利用循环进行遍历：

```c++
struct boyfriend bf1={"jason",18,1.80};
struct boyfriend bf2={"ben",10,1.80};
struct boyfriend bf3={"tony",19,1.80};
//存入数组中
struct bfarr[3]={bf1,bf2,bf3};
for(int i=0;i<3;i++)
{
struct temp=arr[i];
...
}
```

当然，也可以用简化的表示方式(加上`typedef`可在末尾加上简称并在后面使用)

```c++
typedef struct 
{
	char name[100];
	int attack;
	int defense;
	int blood;
}pr;//在末尾写上简称
```

这样后续就可以使用简称代替

```
pr a1 = { "daming",100,10,222 };
```

### 结构体作为函数参数传递的两种方式(内存地址和数据值)

- 用指针的方式传递参数
  - 能把结构体的地址传递过去，从而修改里面的参数

eg.

> `s`为定义结构体的简称

```c
void exchangemessage(s* pst)//细节：必须在结构体后面定义函数
{
	printf("请输入学生的名字");
	scanf("%s", (*pst).name);//(*pst)解引用出结构体
	printf("请输入学生的年龄");
	scanf("%d", &((*pst).age));//(*pst)解引用结构体然后对整个取地址
	printf("修改后的学生名字为:%s,年龄为:%d\n",(*pst).name,(*pst).age);
}
```

- 用结构体的参数传递参数`void funtion (s st)`
  - 相当于定义一个新的变量，仅仅是把数据赋值给新变量，对原本的变量没有影响

eg.

```
void exchangemessage2(s st)//相当于定义了新的变量
{
	printf("请输入学生的名字");
	scanf("%s", st.name);
	printf("请输入学生的年龄");
	scanf("%d", &st.age);
	printf("修改后的学生名字为:%s,年龄为:%d\n", st.name, st.age);

}
```

### 结构体嵌套

>  在结构体中的成员中也是结构体

定义：

```c
struct massage//先定义嵌套里的数据体
{
	char phonenumber[20];
	char mailaddrass[100];
};
struct studern
{
	char name[100];
	int age;
	struct massage msg;//使用这个嵌套时与定义相同
};
```

赋值与输出：`stu.msg.phonenumber`即可使对应的嵌套数据体赋值

eg.

```c
//也可以批量赋值，嵌套数据体处要多一层{}
struct studern stu = { "jason",18,{"13427122821","jasonchan364@gmail.com"} };
printf("学生的邮箱为：%s\n", stu.msg.mailaddrass);
printf("学生的电话号码为:%s", stu.msg.phonenumber);
```

### 内存对齐:face_with_head_bandage:

> 范围：结构体，变量都存在内存对齐

- 规则：只能放在自己类型整数倍的内存地址上
  - 翻译：内存地址/占用字节=结果可以被整除
    - `int`存放位置只能是被`4`整除
    - `double`存放的位置只能是被`8`整除

- 结构体内存对齐：
  - 结构体的内存大小是**最大类型的整数倍**（如最大类型是`double`,结构体的内存大小是`8`的整数倍
  - 对齐时会补空白字节，但*不会改变原本的字节大小（切记）*（`char`补位后本身还是`1`个字节

- 心得：在定义结构体时，先定义占用字节小的数据类型，以达到节省空间的效果

## 共同体union

> - 所有变量都使用一个内存空间
> - 所有的变量都使用同一个内存空间
> - 占用内存大小=最大的成员数据类型的长度（受内存对齐影响）
>   - 以最大单个成员的长度为准
>   - 总大小一定是最大单个成员的整数倍
> - 每次只能给一个变量进行赋值，第二次赋值时会覆盖前一次的数据

结构体与共同体的区别

1. 定义内容：

- 结构体：一种事物包含多个属性(学生信息包括姓名，身高，性别等)

- 共同体：一个属性有多种类型(金钱的多种表达方式)

2. 储存方式:
   - 结构体：各存各的
   - 共同体：存在同一个内存地址，*内容会被覆盖*

3. 内存占用：
   - 结构体: ***所有成员的内存大小总和***，并且大小为最大成员的内存大小的整数倍
   - 共同体：***最大成员的内存大小***，并且大小为最大成员的内存大小的整数倍

## 动态内存分配

### 常见函数

> 定义在`stdlib.h`的头文件

- **`malloc`(memory allocation)**
  
  - 作用：申请（连续）空间

  - `malloc(x)`x表示申请的内存空间
  
  - 使用：
  
    ```c
    int *p=malloc(100*sizeof(int));//返回首地址  
    ```
  
  - 赋值：1. 用数组的方式`p[i]=10`2. 用循环指针`*(p+i)=10`
  
- `calloc`(contiguous allocation)
  
  - 作用：申请空间+*数据初始化*    (初始化数据0)
  - 使用：`int *P=calloc(10,sizeof(int));` `10`表示个数 `sizeof(int)`表示单位长度
  
- `realloc`(re_allocation)
  
  - 作用：修改空间大小
  - 使用：`int*pp=realloc(*p,20*sizeof(int));`
  
- **`free`(free)**
  
  - 作用：释放内存空间
  - 使用：`free(pp)`
  - 申请的空间不使用了，记得要释放。

注意：

1. `malloc`创建的空间的单位是*字节*
2. `malloc`返回的是`void`类型的指针，没有步长的概念，也无法获取空间中的数据，需要强转 `int *p=malloc(100)`
3. `malloc`返回的仅仅是**首地址**(指针p仅仅接收空间的首地址，以及单个步长），没有总大小，最好定义一个变量记录总大小 

```
int *p=malloc(100);
int size=25;
```

4. `malloc`申请的空间不会自动消失，没有正确释放，会导致内存泄漏 
5. `malloc`申请空间过多会产生“虚拟空间"
   - 虚拟空间: 当申请的空间过多，每个内存空间都不会立马使用，当开始存储数据的时候才真正分配空间，**提高内存使用效率**

6. `malloc`申请的空间没有初始化值，需要先赋值才使用
7. `free` 释放完空间之后，空间中的数据叫做”脏数据",可能被清空可能被修改成其他值    *(总之不要使用`free`之后的数据)*
8. `realloc`修改之后的空间，地址值可能发生变化，也可能不发生变化，但原本的数据不会丢失。
9. `realloc`修改后，原本的空间会在底层自动处理
   - 如果内存地址没变，底层在原本的空间后面接着申请
   - 如果内存地址变了，申请一个新的大空间，把原本的数据都拷贝到新空间，再把原本的空间给`free`掉

### 内存结构

 ![img](https://camo.githubusercontent.com/9a5837b2a0a1449f2d536f85e323d62f550af570c3f1ea7deea1adcd779f84a5/68747470733a2f2f63646e2e6e6c61726b2e636f6d2f79757175652f302f323032312f706e672f3333353236382f313632323436393930373538352d32316435353531312d323932372d346439372d613234332d3332653136653136613261332e706e6723636c69656e7449643d7566636538373666392d623664302d342666726f6d3d7061737465266865696768743d3531342669643d753863666239313831266d617267696e3d2535426f626a6563742532304f626a656374253544266e616d653d696d6167652e706e67266f726967696e4865696768743d31303238266f726967696e57696474683d31363234266f726967696e616c547970653d62696e61727926726174696f3d312673697a653d313439393133267374617475733d646f6e65267374796c653d6e6f6e65267461736b49643d7561353261633535612d373463642d346130352d386261332d65623335663764323163332677696474683d383132)



- 全局变量和`static`变量放在`初始化静态区`，一直存在，只有在整个程序结束才会消失

- 函数放在`栈`里，当所在的函数结束，变量消失

- 使用`char *str="abc"`定义的字符串储存在`常量区`不发生修改（无法修改的是`abc`)，可以重复使用。

  ```c
   int main()
   {
   char *str="abc";
   printf("%s\n",str);//打印：abc
   str="aaa";//在常量区生成一个“aaa",并且指针指向新的地址(aaa)
   printf("%s",str);//打印：aaa
   }
  ```

- 使用`char str[4]="123"`定义的字符串储存在`栈`，可以修改。

- 使用`malloc`申请的空间储存在`堆`

- `堆`的内存空间远大于`栈`

## 文件 File

> 路径：文件在电脑 的位置
>
> - 绝对路径 (以盘符开始) 在电脑的完整位置`C:\Users\Desktop\a.txt`
> - 相对路径 (不以盘符开始)*以当前项目为参照物*的相对路径 `aaa\a.txt`
> - `\`转义字符

路径是以字符串的形式来表示

```c
 char *file="C:\\Users\\Desktop\\a.txt"//第一个\表示转移字符
```

### 读取数据

书写步骤：

1. 打开文件`fopen`
2. 读数据 
   - `fgetc`一次读取一个字符，读不到返回-1   
   - `fgets`一次读一行 
   - `fread`一次读多行
3. 关闭文件 `fclose`

- 使用`fgetc`读取文件

```
//打开文件
File* file=fopen("C:\\Users\\Desktop\\a.txt","r")//前面表示文件路径，后面表示读取模式
//读取数据 
int c; 
while((c=fgetc(file))!=-1)
{
printf("%c",c);
}
//关闭文件
fclose(file);
```

- 使用`fgets`读取文件
  - 细节：
    - 每次读取一行数据，以换行符为准
    - 如果读不到了，返回`NULL`

```
2.打开文件
char arr[1024];//定义一个数组来接收数据
fgets(arr,1024,file);//参数分别是：传入的数组，数组的大小，文件名称
//或者使用字符串指针的方式
char *str=fgets(arr,1024,file);
```

使用循环的方式

```
char arr[1024];
char* str;
while((str=fgets(arr,1024,file))!=NUll)
{
printf("%s",str);
}
```

- 使用`fread`读取文件
  - 细节;
    - 使用`fread`函数读取文件会返回一个值表示当前读到的字节数
    - 在读取的时候，`fread`会尽量把数组填埋，没有字节填入数组，会返回0。

```c
2.读取数据
char arr[1024];
int n=fread(arr,1,1024,file);//填入的参数分别表示：传入的数组，数组单位存储大小，
```

 使用循环读取：

```
char arr[1024];
int n;
while((int=fread(arr,1,1024,file))!=0)
{
 for(int 0=i;i<n;i++)
 {
 printf("%c",arr[i]);
 }
}
```

### 写出数据

> - 把程序中的数据写到本地文件中永久存储

步骤:

1. 打开文件 `fopen`
2. 写数据
   - `fputc`一次写一个字符，函数会返回写出的数据
   - `fputs`一次写一个字符串，~~写出成功返回非负数~~
   - `fwrite`一次写入多个，返回写出的个数

3. 关闭通道  `fclose`

 ```
 //打开文件
 fopen("C:\\Users\\Desktop\\a.txt","w")//w表示写入
 //写出数据
 //写入a----97
 int c=fputc(97,file);//函数会返回写入的数据
 int n=fputs("hello_world",flle);//成功返回非负数(忽略)
 //使用fwrite
 char arr[5]={97,98,99,100,101};
 int d=fwrite(arr,1,5,file);//写出abcd
 
 ```

### 读写模式

![image-20241030171039786](D:\Jason\assets\image-20241030171039786.png)

![image-20241030172711707](D:\Jason\assets\image-20241030172711707.png)

-  `r`: *只读模式*
  - 不能写。如果强行写出，数据是无法写到本地文件的
- `w`只写模式
  - *如果文件不存在，那么会把文件创建出来*，但是要保证前面的文件夹都是存在的
  - 如果文件存在，会把**文件原本的数据清空**
  - 清空数据和创建文件都是`fopen`干的事情

- `a`追加写出模式
  - *如果文件不存在，那么会把文件创建出来*，但是要保证前面的文件夹都是存在的
  - 如果文件存在，原本的数据不会清空，而是接着写出（续写）
  - 创建文件和续写都是`fopen`干的事
